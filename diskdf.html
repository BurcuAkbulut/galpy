<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Three-dimensional disk distribution functions &mdash; galpy 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="galpy 1.0 documentation" href="index.html" />
    <link rel="next" title="Dynamical modeling of tidal streams" href="streamdf.html" />
    <link rel="prev" title="Action-angle coordinates" href="actionAngle.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="streamdf.html" title="Dynamical modeling of tidal streams"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="actionAngle.html" title="Action-angle coordinates"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">galpy 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo-small.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Three-dimensional disk distribution functions</a><ul>
<li><a class="reference internal" href="#setting-up-the-df-and-basic-properties">Setting up the DF and basic properties</a></li>
<li><a class="reference internal" href="#evaluating-moments">Evaluating moments</a></li>
<li><a class="reference internal" href="#evaluating-and-sampling-the-full-probability-distribution-function">Evaluating and sampling the full probability distribution function</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="actionAngle.html"
                        title="previous chapter">Action-angle coordinates</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="streamdf.html"
                        title="next chapter">Dynamical modeling of tidal streams</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/diskdf.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="three-dimensional-disk-distribution-functions">
<h1>Three-dimensional disk distribution functions<a class="headerlink" href="#three-dimensional-disk-distribution-functions" title="Permalink to this headline">¶</a></h1>
<p>galpy contains a fully three-dimensional disk distribution:
<tt class="docutils literal"><span class="pre">galpy.df.quasiisothermaldf</span></tt>, which is an approximately isothermal
distribution function expressed in terms of action&#8211;angle variables
(see <a class="reference external" href="http://adsabs.harvard.edu/abs/2010MNRAS.401.2318B">2010MNRAS.401.2318B</a> and
<a class="reference external" href="http://adsabs.harvard.edu/abs/2011MNRAS.413.1889B">2011MNRAS.413.1889B</a>). Recent
research shows that this distribution function provides a good model
for the DF of mono-abundance sub-populations (MAPs) of the Milky Way
disk (see <a class="reference external" href="http://adsabs.harvard.edu/abs/2013MNRAS.434..652T">2013MNRAS.434..652T</a> and
<a class="reference external" href="http://adsabs.harvard.edu/abs/2013ApJ...779..115B">2013ApJ...779..115B</a>). This
distribution function family requires action-angle coordinates to
evaluate the DF, so <tt class="docutils literal"><span class="pre">galpy.df.quasiisothermaldf</span></tt> makes heavy use of
the routines in <tt class="docutils literal"><span class="pre">galpy.actionAngle</span></tt> (in particular those in
<tt class="docutils literal"><span class="pre">galpy.actionAngleAdiabatic</span></tt> and
<tt class="docutils literal"><span class="pre">galpy.actionAngle.actionAngleStaeckel</span></tt>).</p>
<div class="section" id="setting-up-the-df-and-basic-properties">
<h2>Setting up the DF and basic properties<a class="headerlink" href="#setting-up-the-df-and-basic-properties" title="Permalink to this headline">¶</a></h2>
<p>The quasi-isothermal DF is defined by a gravitational potential and a
set of parameters describing the radial surface-density profile and
the radial and vertical velocity dispersion as a function of
radius. In addition, we have to provide an instance of a
<tt class="docutils literal"><span class="pre">galpy.actionAngle</span></tt> class to calculate the actions for a given
position and velocity. For example, for a
<tt class="docutils literal"><span class="pre">galpy.potential.MWPotential2014</span></tt> potential using the adiabatic
approximation for the actions, we import and define the following</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.potential</span> <span class="kn">import</span> <span class="n">MWPotential2014</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">actionAngleAdiabatic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.df</span> <span class="kn">import</span> <span class="n">quasiisothermaldf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aA</span><span class="o">=</span> <span class="n">actionAngleAdiabatic</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>and then setup the <tt class="docutils literal"><span class="pre">quasiisothermaldf</span></tt> instance</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">=</span> <span class="n">quasiisothermaldf</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">aA</span><span class="o">=</span><span class="n">aA</span><span class="p">,</span><span class="n">cutcounter</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>which sets up a DF instance with a radial scale length of
<span class="math">\(R_0/3\)</span>, a local radial and vertical velocity dispersion of
<span class="math">\(0.2\,V_c(R_0)\)</span> and <span class="math">\(0.1\,V_c(R_0)\)</span>, respectively, and a
radial scale lengths of the velocity dispersions of
<span class="math">\(R_0\)</span>. <tt class="docutils literal"><span class="pre">cutcounter=True</span></tt> specifies that counter-rotating stars
are explicitly excluded (normally these are just exponentially
suppressed). As for the two-dimensional disk DFs, these parameters are
merely input (or target) parameters; the true density and velocity
dispersion profiles calculated by evaluating the relevant moments of
the DF (see below) are not exactly exponential and have scale lengths
and local normalizations that deviate slightly from these input
parameters. We can estimate the DF&#8217;s actual radial scale length near
<span class="math">\(R_0\)</span> as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">estimate_hr</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.32908034635647182</span>
</pre></div>
</div>
<p>which is quite close to the input value of 1/3. Similarly, we can
estimate the scale lengths of the dispersions</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">estimate_hsr</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">1.1913935820372923</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">estimate_hsz</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">1.0506918075359255</span>
</pre></div>
</div>
<p>The vertical profile is fully specified by the velocity dispersions
and radial density / dispersion profiles under the assumption of
dynamical equilibrium. We can estimate the scale height of this DF at
a given radius and height as follows</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">estimate_hz</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.125</span><span class="p">)</span>
<span class="go">0.021389597757156088</span>
</pre></div>
</div>
<p>Near the mid-plane this vertical scale height becomes very large
because the vertical profile flattens, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">estimate_hz</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.125</span><span class="o">/</span><span class="mf">100.</span><span class="p">)</span>
<span class="go">1.006386030587223</span>
</pre></div>
</div>
<p>or even</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">estimate_hz</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">187649.98447377066</span>
</pre></div>
</div>
<p>which is basically infinity.</p>
</div>
<div class="section" id="evaluating-moments">
<h2>Evaluating moments<a class="headerlink" href="#evaluating-moments" title="Permalink to this headline">¶</a></h2>
<p>We can evaluate various moments of the DF giving the density, mean
velocities, and velocity dispersions. For example, the mean radial
velocity is again everywhere zero because the potential and the DF are
axisymmetric</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">meanvR</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Likewise, the mean vertical velocity is everywhere zero</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">meanvz</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>The mean rotational velocity has a more interesting dependence on
position. Near the plane, this is the same as that calculated for a similar two-dimensional disk DF (see <a class="reference internal" href="basic_df.html#dftwod-moments"><em>Evaluating moments of the DF</em></a>)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">meanvT</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="go">0.91988346380781227</span>
</pre></div>
</div>
<p>However, this value decreases as one moves further from the plane. The
<tt class="docutils literal"><span class="pre">quasiisothermaldf</span></tt> allows us to calculate the average rotational
velocity as a function of height above the plane. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">zs</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mi">21</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mvts</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qdf</span><span class="o">.</span><span class="n">meanvT</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zs</span><span class="p">])</span>
</pre></div>
</div>
<p>which gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span><span class="n">mvts</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/qdf-meanvtz.png" src="_images/qdf-meanvtz.png" />
<p>We can also calculate the second moments of the DF. We can check
whether the radial and velocity dispersions at <span class="math">\(R_0\)</span> are close
to their input values</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qdf</span><span class="o">.</span><span class="n">sigmaR2</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">))</span>
<span class="go">0.20807112565801389</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qdf</span><span class="o">.</span><span class="n">sigmaz2</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">))</span>
<span class="go">0.090453510526130904</span>
</pre></div>
</div>
<p>and they are pretty close. We can also calculate the mixed <em>R</em> and <em>z</em>
moment, for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">sigmaRz</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.125</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>or expressed as an angle (the <em>tilt of the velocity ellipsoid</em>)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="o">.</span><span class="n">tilt</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.125</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>This tilt is zero because we are using the adiabatic approximation. As
this approximation assumes that the motions in the plane are decoupled
from the vertical motions of stars, the mixed moment is zero. However,
this approximation is invalid for stars that go far above the
plane. By using the Staeckel approximation to calculate the actions,
we can model this coupling better. Setting up a <tt class="docutils literal"><span class="pre">quasiisothermaldf</span></tt>
instance with the Staeckel approximation</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.actionAngle</span> <span class="kn">import</span> <span class="n">actionAngleStaeckel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aAS</span><span class="o">=</span> <span class="n">actionAngleStaeckel</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="mf">0.45</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qdfS</span><span class="o">=</span> <span class="n">quasiisothermaldf</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="n">pot</span><span class="o">=</span><span class="n">MWPotential2014</span><span class="p">,</span><span class="n">aA</span><span class="o">=</span><span class="n">aAS</span><span class="p">,</span><span class="n">cutcounter</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>we can similarly calculate the tilt</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdfS</span><span class="o">.</span><span class="n">tilt</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.125</span><span class="p">)</span>
<span class="go">5.9096430410862419</span>
</pre></div>
</div>
<p>or about 5 degrees. As a function of height, we find</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tilts</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qdfS</span><span class="o">.</span><span class="n">tilt</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zs</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span><span class="n">tilts</span><span class="p">)</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/qdf_tiltz.png" src="_images/qdf_tiltz.png" />
<p>We can also calculate the density and surface density (the zero-th
velocity moments). For example, the vertical density</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">densz</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qdf</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zs</span><span class="p">])</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">denszS</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qdfS</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zs</span><span class="p">])</span>
</pre></div>
</div>
<p>We can compare the vertical profiles calculated using the adiabatic
and Staeckel action-angle approximations</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">semilogy</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span><span class="n">densz</span><span class="o">/</span><span class="n">densz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">semilogy</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span><span class="n">denszS</span><span class="o">/</span><span class="n">denszS</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/qdf-densz.png" src="_images/qdf-densz.png" />
<p>Similarly, we can calculate the radial profile of the surface density</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rs</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">21</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surfr</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qdf</span><span class="o">.</span><span class="n">surfacemass_z</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rs</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surfrS</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qdfS</span><span class="o">.</span><span class="n">surfacemass_z</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rs</span><span class="p">])</span>
</pre></div>
</div>
<p>and compare them with each other and an exponential with scale length
1/3</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">semilogy</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span><span class="n">surfr</span><span class="o">/</span><span class="n">surfr</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">semilogy</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span><span class="n">surfrS</span><span class="o">/</span><span class="n">surfrS</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">semilogy</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">rs</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)))</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/qdf-densr.png" src="_images/qdf-densr.png" />
<p>The two radial profiles are almost indistinguishable and are very
close, if somewhat shallower, than the pure exponential profile.</p>
<p>General velocity moments, including all higher order moments, are
implemented in <tt class="docutils literal"><span class="pre">quasiisothermaldf.vmomentdensity</span></tt>.</p>
</div>
<div class="section" id="evaluating-and-sampling-the-full-probability-distribution-function">
<h2>Evaluating and sampling the full probability distribution function<a class="headerlink" href="#evaluating-and-sampling-the-full-probability-distribution-function" title="Permalink to this headline">¶</a></h2>
<p>We can evaluate the distribution itself by calling the object, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdf</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span> <span class="c">#input: R,vR,vT,z,vz</span>
<span class="go">array([ 16.86790643])</span>
</pre></div>
</div>
<p>or as a function of rotational velocity, for example in the mid-plane</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vts</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pvt</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qdfS</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="n">vt</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span> <span class="k">for</span> <span class="n">vt</span> <span class="ow">in</span> <span class="n">vts</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">vts</span><span class="p">,</span><span class="n">pvt</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vts</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<p>which gives</p>
<img alt="_images/qdf-callvt.png" src="_images/qdf-callvt.png" />
<p>This is, however, not the true distribution of rotational velocities
at <em>R</em> =0 and <em>z</em> =0, because it is conditioned on zero radial and
vertical velocities. We can calculate the distribution of rotational
velocities marginalized over the radial and vertical velocities as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qdfS</span><span class="o">.</span><span class="n">pvT</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span> <span class="c">#input vT,R,z</span>
<span class="go">14.677231196899195</span>
</pre></div>
</div>
<p>or as a function of rotational velocity</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pvt</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qdfS</span><span class="o">.</span><span class="n">pvT</span><span class="p">(</span><span class="n">vt</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span> <span class="k">for</span> <span class="n">vt</span> <span class="ow">in</span> <span class="n">vts</span><span class="p">])</span>
</pre></div>
</div>
<p>overplotting this over the previous distribution gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">vts</span><span class="p">,</span><span class="n">pvt</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pvt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vts</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<img alt="_images/qdf-pvt.png" src="_images/qdf-pvt.png" />
<p>which is slightly different from the conditioned
distribution. Similarly, we can calculate marginalized velocity
probabilities <tt class="docutils literal"><span class="pre">`pvR</span></tt>, <tt class="docutils literal"><span class="pre">pvz</span></tt>, <tt class="docutils literal"><span class="pre">pvRvT</span></tt>, <tt class="docutils literal"><span class="pre">pvRvz</span></tt>, and
<tt class="docutils literal"><span class="pre">pvTvz</span></tt>. These are all multiplied with the density, such that
marginalizing these over the remaining velocity component results in
the density.</p>
<p>We can sample velocities at a given location using
<tt class="docutils literal"><span class="pre">quasiisothermaldf.sampleV</span></tt> (there is currently no support for
sampling locations from the density profile, although that is rather
trivial):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vs</span><span class="o">=</span> <span class="n">qdfS</span><span class="o">.</span><span class="n">sampleV</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="p">(</span><span class="n">vs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">histtype</span><span class="o">=</span><span class="s">&#39;step&#39;</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.5</span><span class="p">])</span>
</pre></div>
</div>
<p>gives</p>
<img alt="_images/qdf-pvtwsamples.png" src="_images/qdf-pvtwsamples.png" />
<p>which shows very good agreement with the green (marginalized over <em>vR</em>
and <em>vz</em>) curve (as it should).</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="streamdf.html" title="Dynamical modeling of tidal streams"
             >next</a> |</li>
        <li class="right" >
          <a href="actionAngle.html" title="Action-angle coordinates"
             >previous</a> |</li>
        <li><a href="index.html">galpy 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010 - 2014, Jo Bovy.
      Last updated on Dec 07, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>