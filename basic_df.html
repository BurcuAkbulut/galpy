<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Two-dimensional disk distribution functions &mdash; galpy 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="galpy 1.0 documentation" href="index.html" />
    <link rel="next" title="A closer look at orbit integration" href="orbit.html" />
    <link rel="prev" title="Potentials in galpy" href="potential.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="orbit.html" title="A closer look at orbit integration"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="potential.html" title="Potentials in galpy"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">galpy 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo-small.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Two-dimensional disk distribution functions</a><ul>
<li><a class="reference internal" href="#types-of-disk-distribution-functions">Types of disk distribution functions</a></li>
<li><a class="reference internal" href="#evaluating-moments-of-the-df">Evaluating moments of the DF</a></li>
<li><a class="reference internal" href="#using-corrected-disk-distribution-functions">Using corrected disk distribution functions</a></li>
<li><a class="reference internal" href="#oort-constants-and-functions">Oort constants and functions</a></li>
<li><a class="reference internal" href="#sampling-data-from-the-df">Sampling data from the DF</a></li>
<li><a class="reference internal" href="#non-axisymmetric-time-dependent-disk-distribution-functions">Non-axisymmetric, time-dependent disk distribution functions</a></li>
<li><a class="reference internal" href="#example-the-hercules-stream-in-the-solar-neighborhood-as-a-result-of-the-galactic-bar">Example: The Hercules stream in the Solar neighborhood as a result of the Galactic bar</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="potential.html"
                        title="previous chapter">Potentials in galpy</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="orbit.html"
                        title="next chapter">A closer look at orbit integration</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/basic_df.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="two-dimensional-disk-distribution-functions">
<h1>Two-dimensional disk distribution functions<a class="headerlink" href="#two-dimensional-disk-distribution-functions" title="Permalink to this headline">¶</a></h1>
<p>galpy contains various disk distribution functions, both in two and
three dimensions. This section introduces the two-dimensional
distribution functions, useful for studying the dynamics of stars that
stay relatively close to the mid-plane of a galaxy. The vertical
motions of these stars may be approximated as being entirely decoupled
from the motion in the plane.</p>
<div class="section" id="types-of-disk-distribution-functions">
<span id="usagediskdfs"></span><h2>Types of disk distribution functions<a class="headerlink" href="#types-of-disk-distribution-functions" title="Permalink to this headline">¶</a></h2>
<p>galpy contains the following distribution functions for razor-thin
disks: <tt class="docutils literal"><span class="pre">galpy.df.dehnendf</span></tt> and <tt class="docutils literal"><span class="pre">galpy.df.shudf</span></tt>. These are the
distribution functions of Dehnen (<a class="reference external" href="http://adsabs.harvard.edu/abs/1999AJ....118.1201D">1999AJ....118.1201D</a>) and Shu
(<a class="reference external" href="http://adsabs.harvard.edu/abs/1969ApJ...158..505S">1969ApJ...158..505S</a>). Everything
shown below for <tt class="docutils literal"><span class="pre">dehnendf</span></tt> can also be done for <tt class="docutils literal"><span class="pre">shudf</span></tt>.</p>
<p>These disk distribution functions are functions of the energy and the
angular momentum alone. They can be evaluated for orbits, or for a
given energy and angular momentum. At this point, only power-law
rotation curves are supported. A <tt class="docutils literal"><span class="pre">dehnendf</span></tt> instance is initialized
as follows</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.df</span> <span class="kn">import</span> <span class="n">dehnendf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">=</span> <span class="n">dehnendf</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
</pre></div>
</div>
<p>This initializes a <tt class="docutils literal"><span class="pre">dehnendf</span></tt> instance based on an exponential
surface-mass profile with scale-length 1/3 and an exponential
radial-velocity-dispersion profile with scale-length 1 and a value of
0.2 at R=1. Different parameters for these profiles can be provided as
an initialization keyword. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">=</span> <span class="n">dehnendf</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">profileParams</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.2</span><span class="p">))</span>
</pre></div>
</div>
<p>initializes the distribution function with a radial scale length of
1/4 instead.</p>
<p>We can show that these distribution functions have an asymmetric drift
built-in by evaluating the DF at R=1. We first create a set of
orbit-instances and then evaluate the DF at them</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.orbit</span> <span class="kn">import</span> <span class="n">Orbit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">=</span> <span class="p">[</span><span class="n">Orbit</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="o">+-</span><span class="mf">0.9</span><span class="o">+</span><span class="mf">1.8</span><span class="o">/</span><span class="mi">1000</span><span class="o">*</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1001</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfro</span><span class="o">=</span> <span class="p">[</span><span class="n">dfc</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">os</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">([</span><span class="mf">1.</span><span class="o">+-</span><span class="mf">0.9</span><span class="o">+</span><span class="mf">1.8</span><span class="o">/</span><span class="mi">1000</span><span class="o">*</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1001</span><span class="p">)],</span><span class="n">dfro</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/basic-df-asydrift.png" src="_images/basic-df-asydrift.png" />
<p>Or we can plot the two-dimensional density at R=1.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfro</span><span class="o">=</span> <span class="p">[[</span><span class="n">dfc</span><span class="p">(</span><span class="n">Orbit</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">0.7</span><span class="o">+</span><span class="mf">1.4</span><span class="o">/</span><span class="mi">200</span><span class="o">*</span><span class="n">jj</span><span class="p">,</span><span class="mf">1.</span><span class="o">-</span><span class="mf">0.6</span><span class="o">+</span><span class="mf">1.2</span><span class="o">/</span><span class="mi">200</span><span class="o">*</span><span class="n">ii</span><span class="p">]))</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">201</span><span class="p">)]</span><span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">201</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfro</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dfro</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.util.bovy_plot</span> <span class="kn">import</span> <span class="n">bovy_dens2d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bovy_dens2d</span><span class="p">(</span><span class="n">dfro</span><span class="p">,</span><span class="n">origin</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s">&#39;gist_yarg&#39;</span><span class="p">,</span><span class="n">contours</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="nb">xrange</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.7</span><span class="p">],</span><span class="n">yrange</span><span class="o">=</span><span class="p">[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">1.6</span><span class="p">],</span><span class="n">xlabel</span><span class="o">=</span><span class="s">r&#39;$v_R$&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s">r&#39;$v_T$&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/basic-df-2d.png" src="_images/basic-df-2d.png" />
</div>
<div class="section" id="evaluating-moments-of-the-df">
<span id="dftwod-moments"></span><h2>Evaluating moments of the DF<a class="headerlink" href="#evaluating-moments-of-the-df" title="Permalink to this headline">¶</a></h2>
<p>galpy can evaluate various moments of the disk distribution
functions. For example, we can calculate the mean velocities (for the
DF with a scale length of 1/3 above)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">meanvT</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.91715276979447324</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">meanvR</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>and the velocity dispersions</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dfc</span><span class="o">.</span><span class="n">sigmaR2</span><span class="p">(</span><span class="mf">1.</span><span class="p">))</span>
<span class="go">0.19321086259083936</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dfc</span><span class="o">.</span><span class="n">sigmaT2</span><span class="p">(</span><span class="mf">1.</span><span class="p">))</span>
<span class="go">0.15084122011271159</span>
</pre></div>
</div>
<p>and their ratio</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">sigmaR2</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="n">dfc</span><span class="o">.</span><span class="n">sigmaT2</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">1.6406766813028968</span>
</pre></div>
</div>
<p>In the limit of zero velocity dispersion (the epicycle approximation)
this ratio should be equal to 2, which we can check as follows</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfccold</span><span class="o">=</span> <span class="n">dehnendf</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">profileParams</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.02</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfccold</span><span class="o">.</span><span class="n">sigmaR2</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="n">dfccold</span><span class="o">.</span><span class="n">sigmaT2</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">1.9947493895454664</span>
</pre></div>
</div>
<p>We can also calculate higher order moments</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">skewvT</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">-0.48617143862047763</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">kurtosisvT</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.13338978593181494</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">kurtosisvR</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">-0.12159407676394096</span>
</pre></div>
</div>
<p>We already saw above that the velocity dispersion at R=1 is not
exactly equal to the input velocity dispersion (0.19321086259083936
vs. 0.2). Similarly, the whole surface-density and velocity-dispersion
profiles are not quite equal to the exponential input profiles. We can
calculate the resulting surface-mass density profile using
<tt class="docutils literal"><span class="pre">surfacemass</span></tt>, <tt class="docutils literal"><span class="pre">sigmaR2</span></tt>, and <tt class="docutils literal"><span class="pre">sigma2surfacemass</span></tt>. The latter
calculates the product of the velocity dispersion squared and the
surface-mass density. E.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">surfacemass</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.050820867101511534</span>
</pre></div>
</div>
<p>We can plot the surface-mass density as follows</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Rs</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">5.</span><span class="p">,</span><span class="mi">151</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">=</span> <span class="p">[</span><span class="n">dfc</span><span class="o">.</span><span class="n">surfacemass</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Rs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">Rs</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/diskdf-surfacemass.png" src="_images/diskdf-surfacemass.png" />
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">Rs</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
</pre></div>
</div>
<img alt="_images/diskdf-logsurfacemass.png" src="_images/diskdf-logsurfacemass.png" />
<p>which shows the exponential behavior expected for an exponential
disk. We can compare this to the input surface-mass density</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">input_out</span><span class="o">=</span> <span class="p">[</span><span class="n">dfc</span><span class="o">.</span><span class="n">targetSurfacemass</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Rs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">Rs</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">input_out</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
</pre></div>
</div>
<img alt="_images/diskdf-surfacemassdiff.png" src="_images/diskdf-surfacemassdiff.png" />
<p>which shows that there are significant differences between the desired
surface-mass density and the actual surface-mass density. We can do
the same for the velocity-dispersion profile</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">=</span> <span class="p">[</span><span class="n">dfc</span><span class="o">.</span><span class="n">sigmaR2</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Rs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">input_out</span><span class="o">=</span> <span class="p">[</span><span class="n">dfc</span><span class="o">.</span><span class="n">targetSigma2</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Rs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">Rs</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">input_out</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
</pre></div>
</div>
<img alt="_images/diskdf-sigma2diff.png" src="_images/diskdf-sigma2diff.png" />
<p>That the input surface-density and velocity-dispersion profiles are
not the same as the output profiles, means that estimates of DF
properties based on these profiles will not be quite
correct. Obviously this is the case for the surface-density and
velocity-dispersion profiles themselves, which have to be explicitly
calculated by integration over the DF rather than by evaluating the
input profiles. This also means that estimates of the asymmetric drift
based on the input profiles will be wrong. We can calculate the
asymmetric drift at R=1 using the asymmetric drift equation derived
from the Jeans equation (eq. 4.228 in Binney &amp; Tremaine 2008), using
the input surface-density and velocity dispersion profiles</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">asymmetricdrift</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.090000000000000024</span>
</pre></div>
</div>
<p>which should be equal to the circular velocity minus the mean rotational
velocity</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.</span><span class="o">-</span><span class="n">dfc</span><span class="o">.</span><span class="n">meanvT</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.082847230205526756</span>
</pre></div>
</div>
<p>These are not the same in part because of the difference between the
input and output surface-density and velocity-dispersion profiles (and
because the <tt class="docutils literal"><span class="pre">asymmetricdrift</span></tt> method assumes that the ratio of the
velocity dispersions squared is two using the epicycle approximation;
see above).</p>
</div>
<div class="section" id="using-corrected-disk-distribution-functions">
<h2>Using corrected disk distribution functions<a class="headerlink" href="#using-corrected-disk-distribution-functions" title="Permalink to this headline">¶</a></h2>
<p>As shown above, for a given surface-mass density and velocity
dispersion profile, the two-dimensional disk distribution functions
only do a poor job of reproducing the desired profiles. We can correct
this by calculating a set of <em>corrections</em> to the input profiles such
that the output profiles more closely resemble the desired profiles
(see <a class="reference external" href="http://adsabs.harvard.edu/abs/1999AJ....118.1201D">1999AJ....118.1201D</a>). galpy supports
the calculation of these corrections, and comes with some
pre-calculated corrections (these can be found <a class="reference external" href="http://github.com/jobovy/galpy#disk-df-corrections">here</a>). For example,
the following initializes a <tt class="docutils literal"><span class="pre">dehnendf</span></tt> with corrections up to 20th
order (the default)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">=</span> <span class="n">dehnendf</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">correct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The following figure shows the difference between the actual
surface-mass density profile and the desired profile for 1, 2, 3, 4,
5, 10, 15, and 20 iterations</p>
<img alt="_images/testSurfacemassCorrections_sigma0_0.5.png" src="_images/testSurfacemassCorrections_sigma0_0.5.png" />
<p>and the same for the velocity-dispersion profile</p>
<img alt="_images/testSigmaCorrections_sigma0_0.5.png" src="_images/testSigmaCorrections_sigma0_0.5.png" />
<p>galpy will automatically save any new corrections that you calculate.</p>
<p>All of the methods for an uncorrected disk DF can be used for the
corrected DFs as well. For example, the velocity dispersion is now</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dfc</span><span class="o">.</span><span class="n">sigmaR2</span><span class="p">(</span><span class="mf">1.</span><span class="p">))</span>
<span class="go">0.19999985069451526</span>
</pre></div>
</div>
<p>and the mean rotation velocity is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">meanvT</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.90355161181498711</span>
</pre></div>
</div>
<p>and (correct) asymmetric drift</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.</span><span class="o">-</span><span class="n">dfc</span><span class="o">.</span><span class="n">meanvT</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.09644838818501289</span>
</pre></div>
</div>
<p>That this still does not agree with the simple <tt class="docutils literal"><span class="pre">dfc.asymmetricdrift</span></tt>
estimate is because of the latter&#8217;s using the epicycle approximation
for the ratio of the velocity dispersions.</p>
</div>
<div class="section" id="oort-constants-and-functions">
<h2>Oort constants and functions<a class="headerlink" href="#oort-constants-and-functions" title="Permalink to this headline">¶</a></h2>
<p>galpy also contains methods to calculate the Oort functions for
two-dimensional disk distribution functions. These are known as the
<em>Oort constants</em> when measured in the solar neighborhood. They are
combinations of the mean velocities and derivatives thereof. galpy
calculates these by direct integration over the DF and derivatives of
the DF. Thus, we can calculate</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">=</span> <span class="n">dehnendf</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">oortA</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.43190780889218749</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">oortB</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">-0.48524496090228575</span>
</pre></div>
</div>
<p>The <em>K</em> and <em>C</em> Oort constants are zero for axisymmetric DFs</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">oortC</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">oortK</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>In the epicycle approximation, for a flat rotation curve <em>A</em> =- <em>B</em> =
0.5. The explicit calculates of <em>A</em> and <em>B</em> for warm DFs quantify how
good (or bad) this approximation is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">oortA</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span><span class="o">+</span><span class="n">dfc</span><span class="o">.</span><span class="n">oortB</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">-0.053337152010098254</span>
</pre></div>
</div>
<p>For the cold DF from above the approximation is much better</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfccold</span><span class="o">=</span> <span class="n">dehnendf</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">profileParams</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.02</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfccold</span><span class="o">.</span><span class="n">oortA</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="n">dfccold</span><span class="o">.</span><span class="n">oortB</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">(0.49917556666144003, -0.49992824742490816)</span>
</pre></div>
</div>
</div>
<div class="section" id="sampling-data-from-the-df">
<h2>Sampling data from the DF<a class="headerlink" href="#sampling-data-from-the-df" title="Permalink to this headline">¶</a></h2>
<p>We can sample from the disk distribution functions using
<tt class="docutils literal"><span class="pre">sample</span></tt>. <tt class="docutils literal"><span class="pre">sample</span></tt> can return either an energy&#8211;angular-momentum
pair, or a full orbit initialization. We can sample 4000 orbits for
example as (could take two minutes)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span> <span class="n">dfc</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span><span class="n">returnOrbit</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">nphi</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then plot the histogram of the sampled radii and compare it to the input surface-mass density profile</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Rs</span><span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">R</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">o</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hists</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span> <span class="n">hist</span><span class="p">(</span><span class="n">Rs</span><span class="p">,</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xs</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">bins</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bins</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">xs</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xs</span><span class="o">*</span><span class="mf">3.</span><span class="p">)</span><span class="o">*</span><span class="mf">9.</span><span class="p">,</span><span class="s">&#39;r-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>E.g.,</p>
<img alt="_images/basic-df-sampleR.png" src="_images/basic-df-sampleR.png" />
<p>We can also plot the spatial distribution of the sampled disk</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">xs</span><span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">x</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">o</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ys</span><span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">y</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">o</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">figure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>E.g.,</p>
<img alt="_images/basic-df-samplexy.png" src="_images/basic-df-samplexy.png" />
<p>We can also sample points in a specific radial range (might take a few
minutes)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span> <span class="n">dfc</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">returnOrbit</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">nphi</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">rrange</span><span class="o">=</span><span class="p">[</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">1.2</span><span class="p">])</span>
</pre></div>
</div>
<p>and we can plot the distribution of tangential velocities</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vTs</span><span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">vxvv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">o</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hists</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span> <span class="n">hist</span><span class="p">(</span><span class="n">vTs</span><span class="p">,</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">],</span><span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xs</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">bins</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bins</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfro</span><span class="o">=</span> <span class="p">[</span><span class="n">dfc</span><span class="p">(</span><span class="n">Orbit</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="n">x</span><span class="p">]))</span><span class="o">/</span><span class="mf">9.</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">3.</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">dfro</span><span class="p">,</span><span class="s">&#39;r-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/basic-df-samplevT.png" src="_images/basic-df-samplevT.png" />
<p>The agreement between the sampled distribution and the theoretical
curve is not as good because the sampled distribution has a finite
radial range. If we sample 10,000 points in <tt class="docutils literal"><span class="pre">rrange=[0.95,1.05]</span></tt> the
agreement is better (this takes a long time):</p>
<img alt="_images/basic-df-samplevTmore.png" src="_images/basic-df-samplevTmore.png" />
<p>We can also directly sample velocities at a given radius rather than
in a range of radii. Doing this for a correct DF gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">=</span> <span class="n">dehnendf</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">correct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vrvt</span><span class="o">=</span> <span class="n">dfc</span><span class="o">.</span><span class="n">sampleVRVT</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hists</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span> <span class="n">hist</span><span class="p">(</span><span class="n">vrvt</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">],</span><span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xs</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">bins</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bins</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfro</span><span class="o">=</span> <span class="p">[</span><span class="n">dfc</span><span class="p">(</span><span class="n">Orbit</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="n">x</span><span class="p">]))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">dfro</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dfro</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="s">&#39;r-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/basic-df-samplevTatR.png" src="_images/basic-df-samplevTatR.png" />
<p>galpy further has support for sampling along a given line of sight in
the disk, which is useful for interpreting surveys consisting of a
finite number of pointings. For example, we can sampled distances
along a given line of sight</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">=</span> <span class="n">dfc</span><span class="o">.</span><span class="n">sampledSurfacemassLOS</span><span class="p">(</span><span class="mf">30.</span><span class="o">/</span><span class="mf">180.</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
</pre></div>
</div>
<p>which is very fast. We can histogram these</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">hists</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span> <span class="n">hist</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.5</span><span class="p">],</span><span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="mi">101</span><span class="p">)</span>
</pre></div>
</div>
<p>and compare it to the predicted distribution, which we can calculate as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">xs</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">bins</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bins</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fd</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dfc</span><span class="o">.</span><span class="n">surfacemassLOS</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mf">30.</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">fd</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="s">&#39;r-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which shows very good agreement with the sampled distances</p>
<img alt="_images/basic-df-sampled.png" src="_images/basic-df-sampled.png" />
<p>galpy can further sample full 4D phase&#8211;space coordinates along a
given line of sight through <tt class="docutils literal"><span class="pre">dfc.sampleLOS</span></tt>.</p>
</div>
<div class="section" id="non-axisymmetric-time-dependent-disk-distribution-functions">
<h2>Non-axisymmetric, time-dependent disk distribution functions<a class="headerlink" href="#non-axisymmetric-time-dependent-disk-distribution-functions" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">galpy</span></tt> also supports the evaluation of non-axisymmetric,
time-dependent two-dimensional DFs. These specific DFs are constructed
by assuming an initial axisymmetric steady state, described by a DF of
the family discussed above, that is then acted upon by a
non-axisymmetric, time-dependent perturbation. The DF at a given time
and phase-space position is evaluated by integrating the orbit
backwards in time in the non-axisymmetric potential until the time of
the initial DF is reached. From Liouville&#8217;s theorem, which states that
phase-space volume is conserved along the orbit, we then know that we
can evaluate the non-axisymmetric DF today as the initial DF at the
initial point on the orbit. This procedure was first used by <a class="reference external" href="http://adsabs.harvard.edu/abs/2000AJ....119..800D">Dehnen
(2000)</a>.</p>
<p>This is implemented in <tt class="docutils literal"><span class="pre">galpy</span></tt> as <tt class="docutils literal"><span class="pre">galpy.df.evolveddiskdf</span></tt>. Such a
DF is setup by specifying the initial DF, the non-axisymmetric
potential, and the time of the initial state. For example, we can look
at the effect of an elliptical perturbation to the potential like that
described by <a class="reference external" href="http://adsabs.harvard.edu/abs/1994ApJ...421..178K">Kuijken &amp; Tremaine</a>. To do this, we
set up an elliptical perturbation to a logarithmic potential that is
grown slowly to minimize non-adiabatic effects</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.potential</span> <span class="kn">import</span> <span class="n">LogarithmicHaloPotential</span><span class="p">,</span> <span class="n">EllipticalDiskPotential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lp</span><span class="o">=</span> <span class="n">LogarithmicHaloPotential</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ep</span><span class="o">=</span> <span class="n">EllipticalDiskPotential</span><span class="p">(</span><span class="n">twophio</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span><span class="n">phib</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">tform</span><span class="o">=-</span><span class="mf">150.</span><span class="p">,</span><span class="n">tsteady</span><span class="o">=</span><span class="mf">125.</span><span class="p">)</span>
</pre></div>
</div>
<p>This perturbation starts to be grown at <tt class="docutils literal"><span class="pre">tform=-150</span></tt> over a time
period of <tt class="docutils literal"><span class="pre">tsteady=125</span></tt> time units. We will consider the effect of
this perturbation on a very cold disk (velocity dispersion
<span class="math">\(\sigma_R = 0.0125\,v_c\)</span>) and a warm disk (<span class="math">\(\sigma_R =
0.15\,v_c\)</span>). We set up these two initial DFs</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">idfcold</span><span class="o">=</span> <span class="n">dehnendf</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">profileParams</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.0125</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idfwarm</span><span class="o">=</span> <span class="n">dehnendf</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">profileParams</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.15</span><span class="p">))</span>
</pre></div>
</div>
<p>and then set up the <tt class="docutils literal"><span class="pre">evolveddiskdf</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.df</span> <span class="kn">import</span> <span class="n">evolveddiskdf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edfcold</span><span class="o">=</span> <span class="n">evolveddiskdf</span><span class="p">(</span><span class="n">idfcold</span><span class="p">,[</span><span class="n">lp</span><span class="p">,</span><span class="n">ep</span><span class="p">],</span><span class="n">to</span><span class="o">=-</span><span class="mf">150.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edfwarm</span><span class="o">=</span> <span class="n">evolveddiskdf</span><span class="p">(</span><span class="n">idfwarm</span><span class="p">,[</span><span class="n">lp</span><span class="p">,</span><span class="n">ep</span><span class="p">],</span><span class="n">to</span><span class="o">=-</span><span class="mf">150.</span><span class="p">)</span>
</pre></div>
</div>
<p>where we specify that the initial state is at <tt class="docutils literal"><span class="pre">to=-150</span></tt>.</p>
<p>We can now use these <tt class="docutils literal"><span class="pre">evolveddiskdf</span></tt> instances in much the same way
as <tt class="docutils literal"><span class="pre">diskdf</span></tt> instances. One difference is that there is much more
support for evaluating the DF on a grid (to help speed up the rather
slow computations involved). Thus, we can evaluate the mean radial
velocity at <tt class="docutils literal"><span class="pre">R=0.9</span></tt>, <tt class="docutils literal"><span class="pre">phi=22.5</span></tt> degree, and <tt class="docutils literal"><span class="pre">t=0</span></tt> by using a grid</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mvrcold</span><span class="p">,</span> <span class="n">gridcold</span><span class="o">=</span> <span class="n">edfcold</span><span class="o">.</span><span class="n">meanvR</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mf">22.5</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">returnGrid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">gridpoints</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span><span class="n">nsigma</span><span class="o">=</span><span class="mf">6.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mvrwarm</span><span class="p">,</span> <span class="n">gridwarm</span><span class="o">=</span> <span class="n">edfcold</span><span class="o">.</span><span class="n">meanvR</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mf">22.5</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">returnGrid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">gridpoints</span><span class="o">=</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">mvrcold</span><span class="p">,</span> <span class="n">mvrwarm</span>
<span class="go">-0.0358753028951 -0.0294763627935</span>
</pre></div>
</div>
<p>The cold response agrees well with the analytical calculation, which
predicts that this is <span class="math">\(-0.05/\sqrt{2}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">mvrcold</span><span class="o">+</span><span class="mf">0.05</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span>
<span class="go">-0.000519963835811</span>
</pre></div>
</div>
<p>The warm response is slightly smaller in amplitude</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">mvrwarm</span><span class="o">/</span><span class="n">mvrcold</span>
<span class="go">0.821633837619</span>
</pre></div>
</div>
<p>although the numerical uncertainty in <tt class="docutils literal"><span class="pre">mvrwarm</span></tt> is large, because
the grid is not sufficiently fine.</p>
<p>We can then re-use this grid in calculations of other moments of
the DF, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">edfcold</span><span class="o">.</span><span class="n">meanvT</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mf">22.5</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="n">gridcold</span><span class="p">)</span>
<span class="go">0.965058551359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">edfwarm</span><span class="o">.</span><span class="n">meanvT</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mf">22.5</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="n">gridwarm</span><span class="p">)</span>
<span class="go">0.915397094614</span>
</pre></div>
</div>
<p>which returns the mean rotational velocity, and</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">edfcold</span><span class="o">.</span><span class="n">vertexdev</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mf">22.5</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="n">gridcold</span><span class="p">)</span>
<span class="go">3.21160878582</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">edfwarm</span><span class="o">.</span><span class="n">vertexdev</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mf">22.5</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="n">gridwarm</span><span class="p">)</span>
<span class="go">4.23510254333</span>
</pre></div>
</div>
<p>which gives the vertex deviation. The reason we have to calculate the
grid out to <tt class="docutils literal"><span class="pre">6nsigma</span></tt> for the cold response is that the response is
much bigger than the velocity dispersion of the population. This
velocity dispersion is used to automatically to set the grid edges,
but sometimes has to be adjusted to contain the full DF.</p>
<p><tt class="docutils literal"><span class="pre">evolveddiskdf</span></tt> can also calculate the Oort functions, by directly
calculating the spatial derivatives of the DF. These can also be calculated on a grid, such that we can do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">oortacold</span><span class="p">,</span> <span class="n">gridcold</span><span class="p">,</span> <span class="n">gridrcold</span><span class="p">,</span> <span class="n">gridphicold</span><span class="o">=</span> <span class="n">edfcold</span><span class="o">.</span><span class="n">oortA</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mf">22.5</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">returnGrids</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">gridpoints</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span><span class="n">derivGridpoints</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">derivphiGrid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">derivRGrid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">nsigma</span><span class="o">=</span><span class="mf">6.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">oortawarm</span><span class="p">,</span> <span class="n">gridwarm</span><span class="p">,</span> <span class="n">gridrwarm</span><span class="p">,</span> <span class="n">gridphiwarm</span><span class="o">=</span> <span class="n">edfwarm</span><span class="o">.</span><span class="n">oortA</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mf">22.5</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">returnGrids</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">gridpoints</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span><span class="n">derivGridpoints</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">derivphiGrid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">derivRGrid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">oortacold</span><span class="p">,</span> <span class="n">oortawarm</span>
<span class="go">0.575494559999 0.526389833249</span>
</pre></div>
</div>
<p>It is clear that these are quite different. The cold calculation is
again close to the analytical prediction, which says that <span class="math">\(A =
A_{\mathrm{axi}}+0.05/(2\sqrt{2})\)</span> where <span class="math">\(A_{\mathrm{axi}} =
1/(2\times0.9)\)</span> in this case:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">oortacold</span><span class="o">-</span><span class="p">(</span><span class="mf">0.5</span><span class="o">/</span><span class="mf">0.9</span><span class="o">+</span><span class="mf">0.05</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="p">))</span>
<span class="go">0.0022613349141670236</span>
</pre></div>
</div>
<p>These grids can then be re-used for the other Oort functions, for
example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">edfcold</span><span class="o">.</span><span class="n">oortB</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mf">22.5</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="n">gridcold</span><span class="p">,</span><span class="n">derivphiGrid</span><span class="o">=</span><span class="n">gridphicold</span><span class="p">,</span><span class="n">derivRGrid</span><span class="o">=</span><span class="n">gridrcold</span><span class="p">)</span>
<span class="go">-0.574674310521</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">edfwarm</span><span class="o">.</span><span class="n">oortB</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mf">22.5</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="n">gridwarm</span><span class="p">,</span><span class="n">derivphiGrid</span><span class="o">=</span><span class="n">gridphiwarm</span><span class="p">,</span><span class="n">derivRGrid</span><span class="o">=</span><span class="n">gridrwarm</span><span class="p">)</span>
<span class="go">-0.555546911144</span>
</pre></div>
</div>
<p>and similar for <tt class="docutils literal"><span class="pre">oortC</span></tt> and <tt class="docutils literal"><span class="pre">oortK</span></tt>. These warm results should
again be considered for illustration only, as the grid is not
sufficiently fine to have a small numerical error.</p>
<p>The grids that have been calculated can also be plotted to show the
full velocity DF. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gridcold</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<p>gives</p>
<img alt="_images/basic-df-nonaxi-cold.png" src="_images/basic-df-nonaxi-cold.png" />
<p>which demonstrates that the DF is basically the initial DF that has been displaced (by a significant amount compared to the velocity dispersion). The warm velocityd distribution is given by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gridwarm</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<p>which returns</p>
<img alt="_images/basic-df-nonaxi-warm.png" src="_images/basic-df-nonaxi-warm.png" />
<p>The shift of the smooth DF here is much smaller than the velocity
dispersion.</p>
</div>
<div class="section" id="example-the-hercules-stream-in-the-solar-neighborhood-as-a-result-of-the-galactic-bar">
<h2>Example: The Hercules stream in the Solar neighborhood as a result of the Galactic bar<a class="headerlink" href="#example-the-hercules-stream-in-the-solar-neighborhood-as-a-result-of-the-galactic-bar" title="Permalink to this headline">¶</a></h2>
<p id="hercules">We can combine the orbit integration capabilities of galpy with the
provided distribution functions and see the effect of the Galactic bar
on stellar velocities. By backward integrating orbits starting at the
Solar position in a potential that includes the Galactic bar we can
evaluate what the velocity distribution is that we should see today if
the Galactic bar stirred up a steady-state disk. For this we
initialize a flat rotation curve potential and Dehnen&#8217;s bar potential</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.potential</span> <span class="kn">import</span> <span class="n">LogarithmicHaloPotential</span><span class="p">,</span> <span class="n">DehnenBarPotential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lp</span><span class="o">=</span> <span class="n">LogarithmicHaloPotential</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dp</span><span class="o">=</span> <span class="n">DehnenBarPotential</span><span class="p">()</span>
</pre></div>
</div>
<p>The Dehnen bar potential is initialized to start bar formation four bar
periods before the present day and to have completely formed the bar two
bar periods ago. We can integrate back to the time before
bar-formation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ts</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dp</span><span class="o">.</span><span class="n">tform</span><span class="p">(),</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">dp.tform()</span></tt> is the time of bar-formation (in the usual
time-coordinates).</p>
<p>We initialize orbits on a grid in velocity space and integrate them</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span><span class="o">=</span><span class="p">[[</span><span class="n">Orbit</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">0.7</span><span class="o">+</span><span class="mf">1.4</span><span class="o">/</span><span class="mi">100</span><span class="o">*</span><span class="n">jj</span><span class="p">,</span><span class="mf">1.</span><span class="o">-</span><span class="mf">0.6</span><span class="o">+</span><span class="mf">1.2</span><span class="o">/</span><span class="mi">100</span><span class="o">*</span><span class="n">ii</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">101</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">101</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">=</span><span class="p">[[</span><span class="n">o</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">ts</span><span class="p">,[</span><span class="n">lp</span><span class="p">,</span><span class="n">dp</span><span class="p">])</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ins</span><span class="p">]</span>
</pre></div>
</div>
<p>We can then evaluate the weight of these orbits by assuming that the
disk was in a steady-state before bar-formation with a Dehnen
distribution function. We evaluate the Dehnen distribution function at
<tt class="docutils literal"><span class="pre">dp.tform()</span></tt> for each of the orbits</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">=</span> <span class="n">dehnendf</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">correct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">=</span> <span class="p">[[</span><span class="n">dfc</span><span class="p">(</span><span class="n">o</span><span class="p">(</span><span class="n">dp</span><span class="o">.</span><span class="n">tform</span><span class="p">()))</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ins</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>This gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">galpy.util.bovy_plot</span> <span class="kn">import</span> <span class="n">bovy_dens2d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bovy_dens2d</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">origin</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s">&#39;gist_yarg&#39;</span><span class="p">,</span><span class="n">contours</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="nb">xrange</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.7</span><span class="p">],</span><span class="n">yrange</span><span class="o">=</span><span class="p">[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">1.6</span><span class="p">],</span><span class="n">xlabel</span><span class="o">=</span><span class="s">r&#39;$v_R$&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s">r&#39;$v_T$&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/diskdf-dehnenhercules.png" src="_images/diskdf-dehnenhercules.png" />
<p>Now that <tt class="docutils literal"><span class="pre">galpy</span></tt> contains the <tt class="docutils literal"><span class="pre">evolveddiskdf</span></tt> described above,
this whole calculation is encapsulated in this module and can be done
much more easily as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">edf</span><span class="o">=</span> <span class="n">evolveddiskdf</span><span class="p">(</span><span class="n">dfc</span><span class="p">,[</span><span class="n">lp</span><span class="p">,</span><span class="n">dp</span><span class="p">],</span><span class="n">to</span><span class="o">=</span><span class="n">dp</span><span class="o">.</span><span class="n">tform</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mvr</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span> <span class="n">edf</span><span class="o">.</span><span class="n">meanvR</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">gridpoints</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span><span class="n">returnGrid</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The gridded DF can be accessed as <tt class="docutils literal"><span class="pre">grid.df</span></tt>, which we can plot as before</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bovy_dens2d</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">origin</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s">&#39;gist_yarg&#39;</span><span class="p">,</span><span class="n">contours</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="nb">xrange</span><span class="o">=</span><span class="p">[</span><span class="n">grid</span><span class="o">.</span><span class="n">vRgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">grid</span><span class="o">.</span><span class="n">vRgrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span><span class="n">yrange</span><span class="o">=</span><span class="p">[</span><span class="n">grid</span><span class="o">.</span><span class="n">vTgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">grid</span><span class="o">.</span><span class="n">vTgrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span><span class="n">xlabel</span><span class="o">=</span><span class="s">r&#39;$v_R$&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s">r&#39;$v_T$&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/diskdf-dehnenhercules-edf.png" src="_images/diskdf-dehnenhercules-edf.png" />
<p>For more information see <a class="reference external" href="http://adsabs.harvard.edu/abs/2000AJ....119..800D">2000AJ....119..800D</a> and
<a class="reference external" href="http://adsabs.harvard.edu/abs/2010ApJ...725.1676B">2010ApJ...725.1676B</a>. Note that the
x-axis in the Figure above is defined as minus the x-axis in these
papers.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="orbit.html" title="A closer look at orbit integration"
             >next</a> |</li>
        <li class="right" >
          <a href="potential.html" title="Potentials in galpy"
             >previous</a> |</li>
        <li><a href="index.html">galpy 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010 - 2014, Jo Bovy.
      Last updated on Dec 07, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>